# -*- coding: utf-8 -*-
"""SNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q4bxEPSPnheMKwCH0SjpYHJwlVsAkJkJ
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

import matplotlib.pyplot as plt
import numpy as np

def imshow(image, ax=None, title=None, normalize=True):
    """Imshow for Tensor."""
    if ax is None:
        fig, ax = plt.subplots()
    image = image.numpy().transpose((1, 2, 0))

    if normalize:
        mean = np.array([0.5, 0.5, 0.5])
        std = np.array([0.5, 0.5, 0.5])
        image = std * image + mean
        image = np.clip(image, 0, 1)

    ax.imshow(image)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_visible(False)
    ax.tick_params(axis='both', length=0)
    ax.set_xticklabels('')
    ax.set_yticklabels('')

    return ax

################################################ README #########################################################

# This file contains all the parameters of the network.

#################################################################################################################

class param:
  scale = 1
  T = 200
  t_back = -20
  t_fore = 20

  pixel_x = 28
  Prest = 0
  m = pixel_x*pixel_x #Number of neurons in first layer
  n =  15  #Number of neurons in second layer
  Pmin = -500*scale
  # Pth = 5
  # D = 0.7
  w_max = 1.5*scale
  w_min = -1.2*scale
  sigma = 0.1 #0.02
  A_plus = 0.8  # time difference is positive i.e negative reinforcement
  A_minus = 0.3 # 0.01 # time difference is negative i.e positive reinforcement 
  tau_plus = 8
  tau_minus = 5

  epoch = 12


  fr_bits = 12
  int_bits = 12
############################################################ README ##############################################################

# This is neuron class which defines the dynamics of a neuron. All the parameters are initialised and methods are included to check
# for spikes and apply lateral inhibition.

###################################################################################################################################

import numpy as np
import random
from matplotlib import pyplot as plt
#from parameters import param as par

class neuron:
  def __init__(self):
    self.t_ref = 30
    self.t_rest = -1
    self.par = param()
    self.P = self.par.Prest
  def check(self):
    if self.P>= self.Pth:
      self.P = self.par.Prest
      return 1	
    elif self.P < self.par.Pmin:
      self.P  = self.par.Prest
      return 0
    else:
      return 0
  def inhibit(self):
    self.P  = self.par.Pmin
  def initial(self, th):
    self.Pth = th
    self.t_rest = -1
    self.P = self.par.Prest

import numpy as np
import cv2
from PIL import Image as pImage

class ToSpikeTrain(object):
  """Convert a ``PIL Image`` or ``numpy.ndarray`` to tensor.
  Converts a PIL Image or numpy.ndarray (H x W x C) in the range
  [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0]
  if the PIL Image belongs to one of the modes (L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK, 1)
  or if the numpy.ndarray has dtype = np.uint8
  In the other cases, tensors are returned without scaling.
  """
  def __init__(self):
    self.par = param()
  def encode(self,pot):
    #initializing spike train
    train = []

    for l in range(self.par.pixel_x):
      for m in range(self.par.pixel_x):
      
        temp = np.zeros([(self.par.T+1),])

        #calculating firing rate proportional to the membrane potential
        freq = interp(pot[l][m], [-1.069,2.781], [1,20])
        
        # print freq
        #if freq<=0:
          #print (error)
          
        freq1 = math.ceil(600/freq)

        #generating spikes according to the firing rate
        k = freq1
        if(pot[l][m]>0):
          while k<(self.par.T+1):
            temp[k] = 1
            k = k + freq1
        train.append(temp)
        # print sum(temp)
    return np.array(train)
  def receptive_field(self, inp):
    sca1 =  0.625
    sca2 =  0.125
    sca3 = -0.125
    sca4 = -.5

    #Receptive field kernel
    w = [[	sca4 ,sca3 , sca2 ,sca3 ,sca4],
      [	sca3 ,sca2 , sca1 ,sca2 ,sca3],
      [ 	sca2 ,sca1 , 	1 ,sca1 ,sca2],
      [	sca3 ,sca2 , sca1 ,sca2 ,sca3],
      [	sca4 ,sca3 , sca2 ,sca3 ,sca4]]
    #print('Input size',inp.shape)
    width, height = inp.shape
    pot = np.zeros([width,height])
    ran = [-2,-1,0,1,2]
    ox = 2
    oy = 2
    
    #print('Using width, height as: ',width,height)
    #Convolution
    for i in range(width):
      for j in range(height):
        summ = 0
        for m in ran:
          for n in ran:
            if (i+m)>=0 and (i+m)<=width-1 and (j+n)>=0 and (j+n)<=height-1:
              summ = summ + w[ox+m][oy+n]*inp[i+m][j+n]/255
        pot[i][j] = summ
    return pot
  def __call__(self, img):
    """
    Args:
        pictensor (PIL Image or numpy.ndarray): Image tensor to be converted to spike train tensor.
    Returns:
        SpikeTensor: Spike train tensor.
    """
    #print('Imgae size',img.size)
    numpyimg = np.array(img)
    #print('numpy array',numpyimg.shape)
    pot = self.receptive_field(numpyimg)
    #Generating spike train
    train = np.array(self.encode(pot))
    #spikeImage = pImage.fromarray(np.uint8(img)).convert('RGB')
    #print(type(spikeImage))
    print('Type of train', type(train))
    print('Dims of train',train.shape)
    return train

  def __repr__(self):
    return self.__class__.__name__ + '()'

# Commented out IPython magic to ensure Python compatibility.
from torch import nn
import torchvision
import torchvision.datasets as datasets
import matplotlib.pyplot as plt
import numpy as np
import math
from IPython.display import Image
from numpy import interp

import matplotlib.pyplot as plt
# %matplotlib inline

class SNN(nn.Module):
  def __init__(self):
    super().__init__()
    self.par = param()
    self.time  = np.arange(1, self.par.T+1, 1)
    #synapse matrix	initialization
    synapse = np.zeros((self.par.n,self.par.m))
    for i in range(self.par.n):
      for j in range(self.par.m):
        synapse[i][j] = random.uniform(0,0.4*self.par.scale)
    self.synapse = nn.Parameter(torch.from_numpy(synapse))
    print('[INFO] Synapses initialized:', self.synapse.size())
    # Load dataset for training
    # The values 0.1307 and 0.3081 used for the Normalize() transformation below are the global mean and standard deviation of the MNIST dataset, we'll take them as a given here.
    # Unsure if normalizing the input images is cool or uncool...
    print('[INFO] Loading datasets...')
    self.mnist_trainset = datasets.MNIST(root='./data', train=True, download=True, transform=torchvision.transforms.Compose([torchvision.transforms.ToTensor(),torchvision.transforms.Normalize((0.1307,), (0.3081,))]))
    self.mnist_testset = datasets.MNIST(root='./data', train=False, download=True, transform=torchvision.transforms.Compose([torchvision.transforms.ToTensor(),torchvision.transforms.Normalize((0.1307,), (0.3081,))]))
    self.mnist_trainset_dataloader = torch.utils.data.DataLoader(self.mnist_trainset)
    self.mnist_testset_dataloader = torch.utils.data.DataLoader(self.mnist_testset)

    # create spike trains for each image
    print('[INFO] Creating spike trains...')
    self.mnist_spike_trainset = datasets.MNIST(root='./data', train=True, download=True, transform=torchvision.transforms.Compose([ToSpikeTrain(),torchvision.transforms.ToTensor()]))
    self.mnist_spike_testset = datasets.MNIST(root='./data', train=False, download=True, transform=torchvision.transforms.Compose([ToSpikeTrain(),torchvision.transforms.ToTensor()]))
    self.mnist_spike_trainset_dataloader = torch.utils.data.DataLoader(self.mnist_spike_trainset)
    self.mnist_spike_testset_dataloader = torch.utils.data.DataLoader(self.mnist_spike_testset)
    # create spike train thresholds
    print('[INFO] Creating spike train thresholds...')
    
    '''
    self.c = 0
    self.train_images, self.train_labels = next(iter(self.mnist_testset_dataloader))
    for images, labels in self.mnist_trainset_dataloader:
      print(images.shape)
      images=torch.squeeze(images)
      to_pil = torchvision.transforms.ToPILImage()
      print(type(images))
      plt.imshow(to_pil(images),cmap='gray')
      plt.title(f"Training {labels[0]}")
      plt.axis('off')
      plt.show()
      self.c+=1
      if self.c ==2:
        break
  '''
  def imagesToSpikeTrain(self, images):
    for image, label in images:
      #print(type(image))
      break
  def train(self):
    for epoch in self.par.epoch:
      for i, data in enumerate(self.mnist_trainset_dataloader, 0):
          # get the inputs; data is a list of [inputs, labels]
          inputs, labels = data

# https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html
# Parameters: https://pytorch.org/tutorials/beginner/nn_tutorial.html

snn = SNN()

